{"componentChunkName":"component---src-templates-post-tsx","path":"/shortest_path/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"최단-경로-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"최단 경로 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최단 경로 알고리즘</h2>\n<p>그래프는 간선에 가중치 정보를 추가할 수 있다. 이런 그래프를 가중 그래프(weighted graph) 라고 하며, 자연스럽게 출발 노드에서 특정 노드로 가는 경로의 가중치 합이 최소가 되는 경로를 찾는 문제가 발생한다. 깊이 우선 탐색(DFS)에서 <code class=\"language-text\">경로의 개수를 최소화</code>하는 것이 목적이었다면 이 문제에서는 가중 그래프에서 <code class=\"language-text\">경로 가중치의 합을 최소화</code> 하는 것이 목적이며, 이 문제를 <code class=\"language-text\">최단 경로 알고리즘</code>이라고 부른다.</p>\n<p>이 글에서는 두개의 최단 경로 알고리즘을 정리하고자 한다.</p>\n<ol>\n<li>Dijkstra 알고리즘</li>\n<li>Floyd-Warshall 알고리즘</li>\n</ol>\n<h2 id=\"1-dijkstra-알고리즘\" style=\"position:relative;\"><a href=\"#1-dijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"1 dijkstra 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Dijkstra 알고리즘</h2>\n<p>Dijkstra 알고리즘은 최단 경로 알고리즘으로, 시작 노드에서 모든 노드까지의 최단 경로를 계산한다. Dijkstra 알고리즘은 매 시점에서 가장 비용이 적은 노드를 선택하는 <strong>그리디 알고리즘</strong>이며, 이 때문에 가중치가 모두 양수(positive number)인 유향(directed) 그래프에 대해서만 작동한다.</p>\n<h3 id=\"우선-순위-큐를-활용한-dijkstra-알고리즘-구현\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-dijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84\" aria-label=\"우선 순위 큐를 활용한 dijkstra 알고리즘 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선 순위 큐를 활용한 Dijkstra 알고리즘 구현</h3>\n<p>Dijkstra 알고리즘은 우선 순위 큐를 활용한 재귀 함수로 구현할 수 있다. </p>\n<ol>\n<li>저장된 최단 거리가 입력 받은 거리보다 짧은 경우, 함수를 종료한다.</li>\n<li>1번에서 끝나지 않은 경우, 현재 노드에서 모든 연결된 노드로 가는 경로를 고려해, 이미 저장된 경로와 거리를 비교한다. 저장된 최단 거리가 계산한 거리보다 긴 경우, 더 짧은 거리로 dist 배열의 해당 값을 변경한다.</li>\n<li>우선 순위 큐가 빌 때 까지 위 과정을 반복한다.</li>\n</ol>\n<p><em>최단 거리를 정렬하기 위해 우선 순위 큐를 사용하지만, 큐를 사용하지 않고서도 알고리즘을 구현할 수 있다.</em></p>\n<h4 id=\"파이썬-코드\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%BD%94%EB%93%9C\" aria-label=\"파이썬 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파이썬 코드</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> heapq <span class=\"token keyword\">import</span> heappush<span class=\"token punctuation\">,</span> heappop\n<span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> defaultdict\n\n<span class=\"token comment\"># 노드 개수 n과 간선 개수 m을 입력받는다.</span>\nn<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 시작 노드를 입력 받는다.</span>\nstart <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 1차원 배열 graph를 초기화한다.</span>\ngraph <span class=\"token operator\">=</span> defaultdict<span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># graph[i]는 (node_number, weight)를 원소로 하는 리스트다.</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> w <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># graph와 노드 개수 n을 입력받아</span>\n<span class=\"token comment\"># `시작 노드`에서 `모든 노드`까지의 최단 거리를 반환한다. </span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">shortest_path</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token comment\"># distance[i] : 시작 노드에서 노드 i 까지의 최단 거리</span>\n    <span class=\"token comment\"># 큰 값으로 초기화한다.</span>\n    INF <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1e9</span><span class=\"token punctuation\">)</span>\n    distance <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">dijkstra</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># q의 원소: (shortest_distance, node_number)</span>\n        <span class=\"token comment\"># 시작노드에서 시작노드까지의 거리는 0이다.</span>\n        hq <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        heappush<span class=\"token punctuation\">(</span>hq<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n        <span class=\"token comment\"># q가 존재하는 한 계속한다.</span>\n        <span class=\"token keyword\">while</span> hq<span class=\"token punctuation\">:</span>\n            dist<span class=\"token punctuation\">,</span> now <span class=\"token operator\">=</span> heappop<span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span>\n            <span class=\"token comment\"># 저장된 최단 거리가 계산한 거리보다 짧은 경우, </span>\n            <span class=\"token comment\"># 변경하지 않는다.</span>\n            <span class=\"token keyword\">if</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> dist<span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">continue</span>\n            <span class=\"token comment\"># 연결된 노드에 대해 새로운 경로의 거리를 비교한다.</span>\n            <span class=\"token keyword\">for</span> n<span class=\"token punctuation\">,</span> d <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                w_dist <span class=\"token operator\">=</span> dist <span class=\"token operator\">+</span> d\n                <span class=\"token comment\"># 저장된 최단 거리가 계산한 거리보다 긴 경우, </span>\n                <span class=\"token comment\"># 더 짧은 거리로 dist 값을 변경한다.</span>\n                <span class=\"token keyword\">if</span> w_dist <span class=\"token operator\">&lt;</span> distance<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    distance<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w_dist\n                    heappush<span class=\"token punctuation\">(</span>hq<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>w_dist<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># 시작노드에 대해 dijkstra를 구현한다.</span>\n    dijkstra<span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> distance\n\nshortest <span class=\"token operator\">=</span> shortest_path<span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"Shortest Path from node </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>start<span class=\"token punctuation\">}</span></span><span class=\"token string\"> to node </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>i<span class=\"token punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>shortest<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>시간 복잡도는 우선 순위 큐의 정렬에 의해 노드 개수 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>과 가중치 개수 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span>에 대해 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(MlogN)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>이다.</p>\n<h2 id=\"2-floyd-warshall-알고리즘\" style=\"position:relative;\"><a href=\"#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"2 floyd warshall 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Floyd-Warshall 알고리즘</h2>\n<p>Floyd-Warshall 알고리즘은 모든 노드에서 모든 노드까지의 최단 경로를 계산하는 <strong>다이내믹 프로그래밍</strong> 알고리즘이다. 따라서 점화식을 알기만 하면 구현이 비교적 간단하다는 장점이 있다.</p>\n<p><code class=\"language-text\">노드 i</code>에서 <code class=\"language-text\">노드 j</code>로 가는 임의의 경로가 있다고 하자. 만약 i에서 j로 가는 다른 경로가 있다면 이 경로는 임의의 경로가 지나지 않는 다른 노드를 거쳐갈 것이다. 다른 노드를 임의로 <code class=\"language-text\">노드 k</code>라고 할때, <code class=\"language-text\">노드 i</code>에서 <code class=\"language-text\">노드 k</code>로 다시 <code class=\"language-text\">노드 k</code>에서 <code class=\"language-text\">노드 j</code>로 가는 경로와 그렇지 않은 경로를 비교할 수 있다. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dist[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>를 노드 i에서 j로 가는 최단 경로라고 정의하면 다음과 같이 점화식을 쓸 수 있다.</p>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span>\n<p>따라서 노드 개수 N에 대해 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">(</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(N, N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>크기의 2차원 배열에 임의의 <code class=\"language-text\">노드 i</code>에서 임의의 <code class=\"language-text\">노드 j</code>로 가는 최단 경로를 저장한다. </p>\n<h3 id=\"floyd-warshall-알고리즘-구현\" style=\"position:relative;\"><a href=\"#floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84\" aria-label=\"floyd warshall 알고리즘 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Floyd-Warshall 알고리즘 구현</h3>\n<ol>\n<li>노드 개수 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>에 대해 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">(</mo><mi>N</mi><mo separator=\"true\">,</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(N, N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> 크기의 2차원 배열을 초기화한다.</li>\n<li>위의 점화식을 이용해 모든 k에 대해 2차원 배열을 순회한다.</li>\n</ol>\n<h4 id=\"파이썬-코드-1\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%BD%94%EB%93%9C-1\" aria-label=\"파이썬 코드 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파이썬 코드</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 노드 개수 n과 간선 개수 m을 입력받는다.</span>\nn<span class=\"token punctuation\">,</span> m <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 2차원 dist 배열을 큰 값으로 초기화 한다.</span>\n<span class=\"token comment\"># dist[i][j] : 노드 i에서 노드 j로 가는 최단 경로</span>\nINF <span class=\"token operator\">=</span> <span class=\"token number\">1e9</span>\ndist <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>INF <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 간선 개수만큼 간선 정보를 2차원 배열에 입력받는다.</span>\n<span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> w <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> w\n\n<span class=\"token comment\"># dist와 노드 개수 n을 입력받아</span>\n<span class=\"token comment\"># `모든 노드`에서 `모든 노드`까지의 최단 거리를 저장한 2차원 배열을 반환한다. </span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">floyd_warshall</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    \n    <span class=\"token keyword\">for</span> k <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># 저장되어 있는 최단 경로 dist[i][j]와</span>\n                <span class=\"token comment\"># 노드 k를 거치는 경로 dist[i][k] + dist[k][j]를 비교한다.</span>\n                dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dist<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> dist<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> dist\n\nshortest <span class=\"token operator\">=</span> floyd_warshall<span class=\"token punctuation\">(</span>dist<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f\"Shortest Path from node </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>i<span class=\"token punctuation\">}</span></span><span class=\"token string\"> to node </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>j<span class=\"token punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>shortest<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Floyd-Warshall 알고리즘은 삼중 for문에 의해 시간 복잡도가 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>이므로 노드 개수가 많은 그래프는 수행시간에 유의해야 한다. </p>\n<hr>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<ol>\n<li>Youtube, (이코테 2021 강의 몰아보기) 7. 최단 경로 알고리즘, <a href=\"https://www.youtube.com/watch?v=acqm9mM1P6o\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=acqm9mM1P6o</a></li>\n</ol>","excerpt":"최단 경로 알고리즘 그래프는 간선에 가중치 정보를 추가할 수 있다. 이런 그래프를 가중 그래프(weighted graph) 라고 하며, 자연스럽게 출발 노드에서 특정 노드로 가는 경로의 가중치 합이 최소가 되는 경로를 찾는 문제가 발생한다. 깊이 우…","tableOfContents":"<ul>\n<li><a href=\"/shortest_path/#%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">최단 경로 알고리즘</a></li>\n<li>\n<p><a href=\"/shortest_path/#1-dijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">1. Dijkstra 알고리즘</a></p>\n<ul>\n<li><a href=\"/shortest_path/#%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-dijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84\">우선 순위 큐를 활용한 Dijkstra 알고리즘 구현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/shortest_path/#2-floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">2. Floyd-Warshall 알고리즘</a></p>\n<ul>\n<li><a href=\"/shortest_path/#floyd-warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84\">Floyd-Warshall 알고리즘 구현</a></li>\n</ul>\n</li>\n<li><a href=\"/shortest_path/#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></li>\n</ul>","fields":{"slug":"/shortest_path/"},"frontmatter":{"title":"최단 경로 알고리즘","date":"Mar 21, 2022","tags":["Algorithms","Shortest Path","Dijkstra Algorithm","Floyd-Warshall Algorithm"],"keywords":["Lab.Snowith","snowith"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/shortest_path/","series":[],"lastmod":"2022-03-21"}},"staticQueryHashes":["2027115977","694178885"]}